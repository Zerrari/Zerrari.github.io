{"meta":{"title":"Zerrari","subtitle":"","description":"","author":"Zerrari","url":"https://zerrari.github.io","root":"/"},"pages":[{"title":"tags","date":"2021-01-27T11:48:54.000Z","updated":"2021-04-08T10:09:52.830Z","comments":true,"path":"tags/index.html","permalink":"https://zerrari.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2021-04-08T09:33:31.000Z","updated":"2021-04-08T09:33:31.509Z","comments":true,"path":"about/index.html","permalink":"https://zerrari.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-01-27T11:48:48.000Z","updated":"2021-04-08T10:10:02.523Z","comments":true,"path":"categories/index.html","permalink":"https://zerrari.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"C++ premier","slug":"Chapter4","date":"2021-05-07T09:51:54.000Z","updated":"2021-05-07T09:50:59.169Z","comments":true,"path":"2021/05/07/Chapter4/","link":"","permalink":"https://zerrari.github.io/2021/05/07/Chapter4/","excerpt":"","text":"Chapter 4数组初始化 数组的维数必须由常量表达式定义。 此常量表达式只能包含整型字面值常量，枚举常量以及初始化的const常量。 非const以及要到运行时才知道值的const常量不能用来定义数组的维数。 const int bufsize = 512; int staffsize = 256; int array1[bufsize]; int array2[staffsize]; error 显示初始化数组元素 int array[3]; array[3] = &#123;1,2,3&#125;; 如果没有显式初始化，则按照普通变量进行初始化。 在函数体外定义，数组的元素自动初始化为0 在函数体内定义，数组的元素不进行自动初始化 不管在哪定义，如果数组的元素为类类型，则调用默认构造函数进行初始化，否则必须进行显式初始化 特殊的字符数组 用字符串字面值来初始化数组时，会添加一个额外的空字符来结束字符串。 char ch1[] = &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;; len: 3 char ch2[] = &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;\\0&#39;&#125;; len :4 char ch3[] = &#123;&quot;abc&quot;&#125;; len:4 指针指针保存的是一个对象的地址。 指针的定义和初始化int *p1; string *p2; string *p1,p2; p1 is a pointer to string,p2 is a string; void*可以保存任何类型的地址。 指针的操作通过解引用来修改指针指向的值。 int val = 10; int *p1 = &amp;val; *p1 = 20; 指向指针的指针 int val = 10; int *p = &amp;val; int **ppi = &amp;p; ppi points to a pointer; 指针和const指针指向const类型的数据时，指针也必须是const类型的不能试图通过指针来修改const类型的数据可以修改const指针指向的非const对象 const int val = 10; const int *p = &amp;val; int *p = &amp;val; error void *p = &amp;val; error const void *p = &amp;val; 字符串c风格字符串的使用 char *cp = &quot;some value&quot;; while (*cp) &#123; //do something to *p cp++; &#125; 字符串结束符NULL 创建动态数组创建int *p = new int[10]; 可以在表达式后面加上一对圆括号来进行初始化int *p = new int[10](); const对象一定要进行初始化const int *p = new int[10](); new操作允许创建长度为零的动态数组。 释放释放p指针指向的数组delete [] p 多维数组初始化int array[2][2] = &#123;&#123;1,1&#125;,&#123;2,2&#125;&#125;; int array[2][2] = &#123;1,1,2,3&#125;; 其他元素被初始化为0 int array[2][2] = &#123;&#123;0&#125;,&#123;1&#125;&#125;; 只初始化了第一行元素 int array[2][2] = &#123;0,1&#125;; 数组的指针int *p[4]; array of pointers to int int (*p)[4]; pointers to an array of 4 ints","categories":[{"name":"cpp","slug":"cpp","permalink":"https://zerrari.github.io/categories/cpp/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}],"author":"Zerrari"},{"title":"调度","slug":"调度1","date":"2021-05-07T09:50:54.000Z","updated":"2021-05-07T09:49:34.824Z","comments":true,"path":"2021/05/07/调度1/","link":"","permalink":"https://zerrari.github.io/2021/05/07/%E8%B0%83%E5%BA%A61/","excerpt":"","text":"单处理器调度分类 长程调度把后备队列里的作业调入内存，并为之建立进程。 中程调度把进程在内存和外存中间转移 短程调度完成进程的调度 调度评价指标 周期时间一个进程从初始化到结束，所用的时间，包括等待的时间。 cpu使用率cpu处在忙状态的占比 吞吐量单位时间完成的进程数量 等待时间进程在就绪队列中的总时间 响应时间从请求被提交到第一次被响应所花的时间 调度算法先来先服务FCFS该算法维护一个单一的就绪队列，进入时间早的位于队列头部，当所运行的进程阻塞时，运行队列的下一个进程。当堵塞的进程就绪时，将其放入队列的尾部。 优点：易于理解，便于应用 最短作业优先先运行所需要运行时间最短的进程。 缺点：可能会导致长作业饥饿 最短剩余时间优先最短作业优先的抢占版本，总是挑选剩余时间最短的进程运行。当有新的进程进入时，将其与现在运行的进程比较，如果运行时间更短，就去运行新的进程。 轮转调度对每个进程运行相同的时间片，时间片用完后，执行下一个进程。 时间片太短，容易造成过多的上下文切换；时间片太长，导致响应时间慢。 优先级调度不同的进程具有不同的优先级，先执行优先级高的进程。 两种方法防止高优先级进程无休止运行下去： 在每个时钟中断后，降低所运行进程的优先级 给每一个进程赋予运行的最大时间片 如果不对优先级进行调整，容易造成低优先级的进程饿死。","categories":[{"name":"OS","slug":"OS","permalink":"https://zerrari.github.io/categories/OS/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}],"author":"Zerrari"},{"title":"C++ premier","slug":"Chapter3","date":"2021-05-06T12:51:54.000Z","updated":"2021-05-06T12:51:52.903Z","comments":true,"path":"2021/05/06/Chapter3/","link":"","permalink":"https://zerrari.github.io/2021/05/06/Chapter3/","excerpt":"","text":"Chapter 3内置变量的初始化 函数体外的变量被初始化为0 函数体内的变量不进行自动初始化 string初始化定义一个空字符串 string x; 将x1初始化为x2的副本 string x1(x2); 将x3初始化为字符串副本 string x3(&#39;abcd&#39;); 将x4初始化为n个字符的副本 string x4(n,&#39;c&#39;); string变量的读写 读取并忽略开头的空白字符（如空格，换行符和制表符） 读取到下一个空白字符停止 读入未知数目的字符串while (cin &gt;&gt; s) &#123;statement&#125; getline 不忽略换行符，即使读取到的第一个字符为换行符，也将他输出 string对象的基本操作s.empty(); s.size(); s[n]; s1+s2; s1 = s2; s1 == s2; 和字符串字面值的连接string s1(&quot;hello&quot;); string s2(&quot;world&quot;&#39;); string s3 = s1 + s2; string s4 = s1 + &quot;world&quot;; string s5 = &quot;hello&quot; + s2; string s6 = &quot;hello&quot; + &quot;,&quot;; error string s7 = &quot;hello&quot; + &quot; &quot; + s2; error vectorvector是同一种类型对象的集合。 构造函数vector&lt;T&gt; v1; vector&lt;T&gt; v1(v2); vector&lt;T&gt; v1(n,i); vector&lt;T&gt; v1(n); 根据类型初始化，如int为0，string为空字符串 vector对象的操作v.empty(); v.size(); v.push_back(); 将一个新元素添加到vector的尾部 v[n]; v1 = v2; v1 == v2; 下标操作只能对已知元素进行操作。 迭代器vector&lt;int&gt;::iterator iter = v.begin(); begin 指向第一个元素 end 指向末端元素的下一个 用解引用来访问迭代器指向的元素*iter 用自增来迭代iter++ 迭代器的算术操作 iter + n iter - n iter1 -iter2 迭代器必须指向同一个容器中的元素 bitset初始化bitset&lt;n&gt; b; bitset&lt;n&gt; b(u); bitset&lt;n&gt; b(s); bitset&lt;b&gt; b(s,pos,n); 用unsigned long和string来初始化bitset对象，高位不足置0，溢出舍弃，值得注意的是string来初始化要反向写入。","categories":[{"name":"cpp","slug":"cpp","permalink":"https://zerrari.github.io/categories/cpp/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}],"author":"Zerrari"},{"title":"xv6源码理解","slug":"xv6源码理解","date":"2021-04-30T04:25:08.000Z","updated":"2021-04-30T06:03:23.741Z","comments":true,"path":"2021/04/30/xv6源码理解/","link":"","permalink":"https://zerrari.github.io/2021/04/30/xv6%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/","excerpt":"","text":"pagetable关于页表的代码在vm.c中，定义则存放在risv.h 页表结构xv6中的虚拟地址为64位，前25位不被用在地址翻译中，中间27位为页表的索引。xv6采用三级页表，9位对应一个页表条目的索引，该页表条目指向下一级页表，最后12位偏移（offset）。 由最后一级页表所对应的页表条目的44位物理页号加上12位偏移，组成56位物理地址。 每一级页表为4096字节，每一级页表有512个页表条目。每一个页表条目有54位。分别为44位的物理页号（phsical page number）和10位的标志位。比如，是否有效或者可读写。 risv.h#define PGROUNDUP(sz) (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1)) #define PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1)) 这两个宏定义，是在分配内存时保证内存字节对齐。其中PGSIZE是对齐因子，即页表的大小，sz为申请的大小PGROUNDUP用来确定要分配内存的上界，PGROUNDDOWN来确定要分配内存的下界 可参考分配内存对齐的内存空间 #define PGSHIFT 12 #define PXMASK 0x1FF #define PXSHIFT(level) (PGSHIFT+(9*(level))) #define PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK) 以上宏定义是用来提取虚拟地址中的9位索引。PXSHIFT来计算所要求索引的位数，如level = 0，PXSHIFT = 12，通过PX取得最后一级页表的索引。 #define PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10) #define PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12) #define PTE_FLAGS(pte) ((pte) &amp; 0x3FF) PA2PTE将物理地址转换为页表条目。PTE2PA将页表条目转换为物理地址。PTE_FLAGS取得页表条目中的标志位。 vm.c","categories":[],"tags":[]},{"title":"字节对齐","slug":"字节对齐","date":"2021-04-30T01:17:30.000Z","updated":"2021-04-30T02:22:06.491Z","comments":true,"path":"2021/04/30/字节对齐/","link":"","permalink":"https://zerrari.github.io/2021/04/30/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/","excerpt":"","text":"字节对齐原因计算机访问内存内存地址的时候，都是对特定的内存地址进行访问，如果不进行内存对齐，可能需要访问两次内存，造成时间的消耗。 规则 数据类型自身的对齐（如short型为2字节） 结构体的对齐，成员中自身对齐值最大的那个值 指定对齐值 #pargma pack (n) 数据成员和结构体的有效对齐值,自身对齐值和指定对齐值小的那个值 有效对齐N 就是指%N = 0 如何去判断一个结构体的所占字节数，首先我们要保证的是每个成员自己的对齐，比如，对于int类型，要求是4字节的对齐，其次，再是结构体的对齐，所依据的就是有效对齐值，选择自身对齐值和指定对齐值小的那个值。 对于指定对齐值，#pargma pack(n),如果定义了，对于每一个数据类型的对齐值和结构体的对齐值，都会和n进行比较，把更小的作为当前的对齐值。 如果没有指定，就按照默认去判断所占的字节数。 为什么又要对于结构体整体进行对齐呢？ 为了保证小一个存储的元素，能够字节对齐。 实例struct m&#123; int a; char b; short c; &#125;; struct n&#123; char b; int a; short c; &#125;; sizeof(struct m) = 8 sizeof(struct n) = 12 第一个例子： 假设从0地址开始摆放，可以看到第一个元素为int类型，4字节，满足0 % 4 = 0，所以所占空间为0~3; 第二个元素为char类型，1字节，满足4 % 1 = 0，所以所占空间为4~5； 第三个元素为short类型，2字节，满足6 % 2 = 0，所以所占空间为6~7； 结构体的对齐值为4字节，即成员中对齐值最大的，满足8 % 4 = 0。所以总体占8字节. 第二个例子： 还是假设从0地址开始摆放，第一个元素为char类型，1字节，满足0 % 4 = 0，所以所占空间为0~3， 由于第二个元素为int类型，4字节，不满足1 % 4 = 0，所以填充三个字节的空闲字节，满足4 % 4 = 0，所以所占空间为4~7； 第三个元素为short类型，2字节，满足8 % 2 = 0，所以所占空间为8~9； 结构体的的对齐值为4字节，不满足10 % 4 = 0，所以填充两个空闲字节。所以总体占12字节。 #pargma pack(2) struct m&#123; int a; long b; char c; &#125;; sizeof(struct m) = 14 struct m&#123; int a; long b; char c; &#125;; sizeof(struct m) = 24","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"https://zerrari.github.io/tags/OS/"}],"author":"Zerrari"},{"title":"LZMA Compress Algorithm","slug":"LZMA-Compress-Algorithm","date":"2021-04-22T11:00:40.000Z","updated":"2021-04-22T13:17:36.585Z","comments":true,"path":"2021/04/22/LZMA-Compress-Algorithm/","link":"","permalink":"https://zerrari.github.io/2021/04/22/LZMA-Compress-Algorithm/","excerpt":"","text":"LZMA参加中兴压缩算法的时候，在python的库中，发现了三个压缩库，分别是zlib,bz2,gzip 以及就是lzma。最后，压缩效果最好的就是lzma算法。所以好好研究这个算法，当作是参加这次比赛的一个收获吧。","categories":[{"name":"Compress","slug":"Compress","permalink":"https://zerrari.github.io/categories/Compress/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}],"author":"Zerrari"},{"title":"xv6-shell","slug":"xv6-shell","date":"2021-04-16T10:52:46.000Z","updated":"2021-04-16T10:54:08.642Z","comments":true,"path":"2021/04/16/xv6-shell/","link":"","permalink":"https://zerrari.github.io/2021/04/16/xv6-shell/","excerpt":"","text":"shell in xv6","categories":[{"name":"OS","slug":"OS","permalink":"https://zerrari.github.io/categories/OS/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}],"author":"Zerrari"},{"title":"The key of vim","slug":"The-key-of-vim","date":"2021-04-16T09:29:34.000Z","updated":"2021-04-16T09:45:16.139Z","comments":true,"path":"2021/04/16/The-key-of-vim/","link":"","permalink":"https://zerrari.github.io/2021/04/16/The-key-of-vim/","excerpt":"","text":"Vimmacro Type q[a-z] to start record a macro. Input your command. Type q to restore the macro. Type [count]@[a-z] to play back commands. substitute:%s/from/to/[flags] %means substitute every occurrence of every line. You can also select lines in visual mode,and use substitute. flags g substitute every occurrence of a line c ask for confirmation before substituting","categories":[{"name":"Vim","slug":"Vim","permalink":"https://zerrari.github.io/categories/Vim/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zerrari.github.io/tags/Linux/"}],"author":"Zerrari"},{"title":"primes lab","slug":"primes-lab","date":"2021-04-11T05:09:04.000Z","updated":"2021-04-11T05:21:49.300Z","comments":true,"path":"2021/04/11/primes-lab/","link":"","permalink":"https://zerrari.github.io/2021/04/11/primes-lab/","excerpt":"","text":"primes lab本次实验要求通过管道之间的通信，来达到筛选出素数的目的。 通过管道的传输，将第一个值输出，并将后面的数字第一个值相除，如果能除尽，就丢弃。 通过递归调用，不断建立子进程，进行筛选。 进程之间的变量子进程产生后，复制父进程变量的值，但由于两者是不同进程空间的，所以两个变量没有关系。 为了能将值从子进程传递给父进程，通过管道来将值进行传递。","categories":[{"name":"OS","slug":"OS","permalink":"https://zerrari.github.io/categories/OS/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}],"author":"Zerrari"},{"title":"mit6.S081","slug":"mit6-S081","date":"2021-04-10T02:25:25.000Z","updated":"2021-04-10T10:00:50.276Z","comments":true,"path":"2021/04/10/mit6-S081/","link":"","permalink":"https://zerrari.github.io/2021/04/10/mit6-S081/","excerpt":"","text":"Chapter1System Call process and memoryA process creates new process with fork In the parent,fork returns child’s PID. In the child,fork returns zero. wait wait for the child to exit exit cause the process stopping executing return 0 to indicate success return 1 to indecate failure argc,argvargc,the number of arguments including the cmd grep -n --color &#39;xxx&#39; input.txt argc = 5 argv[0] = &quot;grep&quot; argv[1] = &quot;-n&quot; argv[2] = &quot;--color&quot; ... I/O and File descriptors 0 standard input 1 standard output 2 standard error And if your open a new file,its file descriptor will be 3. read(fd,buf,n) read n bytes from file descriptor fd , return the number of bytes read write(fd,buf,n) write n bytes from buf to fd return the number of bytes write pipesA pipe is a pair of file descriptors,one for writing and one for reading. file systemAs an existing file, it has unique inode link(&quot;a&quot;,&quot;b&quot;) link creates new file b,but it has the same inode with the a labsleepint main(int argc,char* argv[]) &#123; //check the number of arguments if (argc &lt;= 1 || argc &gt; 2) &#123; printf(&quot;No argument\\n&quot;); // 1 stands for error exit(1); &#125; int time = atoi(argv[1]); if (time == 0) &#123; printf(&quot;Unvalid argument\\n&quot;); exit(1); &#125; else &#123; sleep(time); &#125; exit(0); &#125; pingpongint main(int argc,char *argv[]) &#123; //create array to store two file descriptors int p[2]; //create pipe pipe(p); //check if the process is child //if fork() returns 0,it is child //else it returns the child PID if (fork() == 0) &#123; char son[10]; //read from file descriptors p[0] read(p[0],son,7); if (strcmp(son,&quot;Trying&quot;) == 0) &#123; int pid = getpid(); printf(&quot;%d: received ping\\n&quot;,pid); write(p[1],&quot;Success&quot;,7); //exit child process exit(0); &#125; &#125; else &#123; char father[10]; //write to file descriptors p[1] write(p[1],&quot;Trying&quot;,7); wait(0); read(p[0],father,7); if (strcmp(father,&quot;Success&quot;) == 0) &#123; int pid = getpid(); printf(&quot;%d : received pong\\n&quot;,pid); &#125; &#125; //exit parent process exit(0); &#125;","categories":[{"name":"OS","slug":"OS","permalink":"https://zerrari.github.io/categories/OS/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}],"author":"Zerrari"},{"title":"sed","slug":"sed","date":"2021-04-08T01:04:32.000Z","updated":"2021-04-08T06:02:14.893Z","comments":true,"path":"2021/04/08/sed/","link":"","permalink":"https://zerrari.github.io/2021/04/08/sed/","excerpt":"","text":"sed$ sed SCRIPTS INPUTFILES... command line option不产生输出，除非存在pcommand $ sed -n $ sed --quiet $ sed --silent 直接修改源文件 $ sed -i &#39;s/my/z/g&#39; text scriptsyntax [addr]X[options] X is a command $ sed &#39;30,35d&#39; input.txt d is a command 30,35 is addrscript内的命令用;隔开多个脚本用-e说明 $ sed &#39;30,35d ; s/hello/world&#39; input.txt $ sed -e &#39;30,35d&#39; -e &#39;s/hello/world&#39; input.txt s command$ sed &#39;s/regexp/replacement/flags input.txt&#39; s控制行的匹配flags控制行内的匹配 在一到三行中匹配$ sed &#39;1,3s/regexp/replacement/flags input.txt&#39; 匹配行内的第一个$ sed &#39;s/regexp.replacement/1&#39; input.txt delete$ sed &#39;2d&#39; input.txt print$ sed &#39;2p&#39; input.txt append$ sed &#39;2a hello&#39; input.txt $ sed &#39;2a/ hello&#39; input.txt insert $ sed &#39;2i/ hello&#39; input.txt","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zerrari.github.io/categories/Linux/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}]},{"title":"Regular Expression","slug":"Regular-Expression","date":"2021-04-07T05:16:26.000Z","updated":"2021-04-07T13:32:39.821Z","comments":true,"path":"2021/04/07/Regular-Expression/","link":"","permalink":"https://zerrari.github.io/2021/04/07/Regular-Expression/","excerpt":"","text":"regular expression语法字符类| 字符 | 含义 ||———–|——————————————–|| . | 匹配任意一个字符 || [ ] | 匹配括号内的任意一个字符 || - | 在[]内表示范围 || ^ | 位于[]内的开头，表示匹配除括号内的字符以外 || [[:xxx:]] | 预定义的字符类 [[:alpha:]] | 数量限定符| 字符 | 含义 ||——-|—————————————-|| ? | 紧跟在它的单元匹配零次或一次 || + | 紧跟在它的单元匹配一次或多次 || * | 紧跟在它的单元匹配零次或多次 || {N} | 紧跟在它的单元匹配N次 || {N,} | 紧跟在它的单元至少匹配N次 || {,M} | 紧跟在它的单元至多匹配M次 || {N,M} | 紧跟在它的单元至少匹配N次，至多匹配M次 | 位置限定符| 字符 | 含义 ||——|———————-|| ^ | 限定行首 || $ | 限定行尾 || \\&lt; | 匹配单词的开头 || \\&gt; | 匹配单词的结尾 || \\b | 匹配单词开头或结尾 || \\B | 不匹配单词开头或结尾 | 实例匹配IP地址 egrep -n --color &#39;([0-9]\\.)&#123;3&#125;[0-9]&#123;3&#125;&#39;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zerrari.github.io/categories/Linux/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}]},{"title":"shell实战","slug":"shell实战","date":"2021-04-07T04:19:18.000Z","updated":"2021-04-07T05:07:37.642Z","comments":true,"path":"2021/04/07/shell实战/","link":"","permalink":"https://zerrari.github.io/2021/04/07/shell%E5%AE%9E%E6%88%98/","excerpt":"","text":"shell本文的重点在于shell脚本的编写。 调用shell脚本方式一 $ chmod +x test.sh $ ./test.sh 方式二 $ /bin/sh test.sh 基本语法变量定义一个变量,变量名一般有大写字母构成，其中不能用空格分隔$ VAR=value 一个变量仅存在于当前shell进程，用export可以将本地变量变为环境变量$ export VAR=value 删除已定义的变量$ unset VAR 取变量名时，要用$$ echo $VAR$ echo $&#123;var&#125;abc 文件名代换wildcard ? 匹配一个任意字符 匹配零个或多个任意字符 [] 匹配括号内的任意字符 命令代换 $ DATE=`date` $ echo $DATE 或是用$()来表示 $ DATE=$(date) 算术代换$(())将其中的shell变量取值转换成整数 $ VAR=45 $ echo $(($VAR+3)) 条件测试是否存在一个目录[ -d DIR ] 是否存在一个文件[ -f FILE ] 如果STRING的长度为零则为真[ -z STRING ] [ -n STRING ] [ STRING1 = STRING2 ] [ arg1 op arg2 ] op -eq 等于 -ne 不等于 -lt 小于 -le 小于等于 -gt 大于 -ge 大于等于 与或非 [ expr1 -a expr2] [ expr1 -o expr2 ] [ ! expr ] ifif [ &quot;$YES_OR_NO&quot; = &quot;yes&quot; ]; then echo &quot;Good morning!&quot; elif [ &quot;$YES_OR_NO&quot; = &quot;no&quot; ]; then echo &quot;Good afternoon!&quot; else echo &quot;Sorry, $YES_OR_NO not recognized. Enter yes or no.&quot; fi casecase &quot;$YES_OR_NO&quot; in yes|y|Yes|YES) echo &quot;Good Morning!&quot;;; [nN]*) echo &quot;Good Afternoon!&quot;;; *) echo &quot;Sorry, $YES_OR_NO not recognized. Enter yes or no.&quot;;; esac forfor NAME in John,Mike; do echo $NAME done whilewhile [ &quot;$TRY&quot; != &quot;secret&quot; ]; do echo &quot;Sorry, try again&quot; done 函数调用时不用加括号 foo() &#123; echo &quot;hello world&quot; &#125; 调试方法 -n 读一遍命令，但不执行，用来检查语法错误 -x 跟踪执行信息，将每一条命令和输出打印出来 在命令行使用参数$ sh -x ./test.sh 在脚本文件的第一行声明`#! /bin/sh -x","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zerrari.github.io/categories/Linux/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}]},{"title":"awk","slug":"awk","date":"2021-04-01T10:17:54.000Z","updated":"2021-04-08T09:56:30.371Z","comments":true,"path":"2021/04/01/awk/","link":"","permalink":"https://zerrari.github.io/2021/04/01/awk/","excerpt":"","text":"awkawk [options] &#39;pattern action&#39; file 常见的actionprint 打印文件的第五列awk &#39;&#123;print $5&#125;&#39; txt $0 表示整行$NF表示最后一列 使用逗号来分隔，输出多列awk &#39;&#123;print $1,$2&#125;&#39; txt 可以添加自己的字段awk &#39;&#123;print $1,&quot;string&quot;&#125; txt&#39; BEGIN在处理文本前要执行的动作awk &#39;BEGIN&#123;print $1&#125;&#39; txt END在处理文本后要执行的动作 分隔符指定#为输入分隔符awk -F# &#39;&#123;print $1&#125; txt&#39; awk -v FS=&#39;#&#39; &#39;&#123;print $1&#125; txt&#39; 指定#为输出分隔符awk -v OFS=&#39;#&#39; &#39;&#123;print $1&#125; txt&#39; 变量NR行号 NF列号 输出带有行号awk &#39;&#123;print NR,$0&#125; txt&#39; FNR多个文件的行号awk &#39;&#123;print FNR,$0&#125; txt1,txt2&#39; RS输入行分隔符将空格作为行分隔符awk -v RS=&#39; &#39; &#39;&#123;print $0&#125;&#39; txt FILENAME文件名awk &#39;&#123;print FILENAME,$0&#125; txt&#39; ARGC参数的数量 ARGV参数的值awk &#39;&#123;print ARGC,ARGV[0],ARGV[1]&#125;&#39; txt 自定义变量awk -v var=&quot;var&quot; &#39;&#123;print var,$0&#125;&#39; txt awk &#39;&#123;var=&quot;myVar&quot;;print var,$0&#125;&#39; txt","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zerrari.github.io/categories/Linux/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}],"author":"Zerrari"},{"title":"a linux command in a day","slug":"a-linux-command-in-a-day","date":"2021-03-30T01:40:13.000Z","updated":"2021-03-30T02:16:46.614Z","comments":true,"path":"2021/03/30/a-linux-command-in-a-day/","link":"","permalink":"https://zerrari.github.io/2021/03/30/a-linux-command-in-a-day/","excerpt":"","text":"grepgrep [option...] [pattern] [file...] 匹配控制忽略大小写搜索 -i --ignore-case 不忽略大小写搜索--no-ignore-case 反转搜索，输出没有匹配的文件 -v --invert-match 输出控制输出匹配的数目 -c --count 高亮匹配的字符 --color 列出匹配的文件 -l --files-with-match 列出不匹配的文件 -L --files-without-match 指定数目匹配匹配到该数目即停止 -m count 仅输出匹配的部分，如果匹配的是一个单词，就输出一个匹配的单词 -o --only-matching 不输出任何匹配信息，包括错误 -q --quiet --silent 输出匹配行所在行号 -n --number 输出匹配行所在的文件名 -H --with-filename -h --no-filename 输出上下文输出匹配行之前的行 -A num --after-context=num 输出匹配行之后的行 -B num --before-context=num 输出之前和之后的匹配行 -C num --context=num","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zerrari.github.io/categories/Linux/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}]},{"title":"virtual memory","slug":"virtual-memory","date":"2021-03-28T09:51:34.000Z","updated":"2021-03-28T10:59:02.296Z","comments":true,"path":"2021/03/28/virtual-memory/","link":"","permalink":"https://zerrari.github.io/2021/03/28/virtual-memory/","excerpt":"","text":"虚拟内存地址的虚拟化和转换为每一个进程开辟出一个地址空间，地址空间的大小可以大于物理内存的大小。 地址的转换（基于硬件）通过基值寄存器和限制寄存器，来进行程序对内存访问的重定位。将虚拟地址加上基值寄存器所存储的值，即是物理地址的值。通过限制寄存器来防止这个进程对其他进程的物理内存进行操作。 分段将栈段，堆段和代码段分段独立地放置在物理内存中，给每一段分配基值寄存器和限制寄存器。节省了栈和堆之间的空闲空间所占有的物理内存。 空闲空间的管理操作系统会用一张链表来记录空闲空间的分布，一个值表明当前空闲块的大小，另外一个为指向下一个空闲块的指针。 分裂和合并当系统需要内存分配空间的时候，空闲块会分裂出合适大小的内存块供系统使用。 当存在相邻的空闲块时，会进行合并，以提高内存的使用率。 空闲块的算法malloc会分配比要求更大的内存，在已分配的内存上附加一个头块，头块包含分配的内存大小以及一个魔数 最优适配寻找空闲块中最大的空闲块，来进行内存分配。 需要遍历整个列表。 最快适配寻找第一个有足够空间的内存块，来进行分配。 速度快，容易在内存头部造成很多外部碎片。 最坏适配寻找最小的能够分配的内存块，来进行分配。 同样要遍历整个列表。 下次匹配从上一次结束的位置开始查找，将分配扩散到整个列表中去。 分页将虚拟内存和物理内存分页管理物理内存每一页又叫页帧。虚拟内存每一页的大小和物理内存每一页的大小相同。虚拟内存的地址前一部分是虚拟页表号，后一部分是在该页上的偏移。每个进程拥有一张页表，上面是虚拟页表到页帧的对应关系。 页表是一个数据结构，可以是链表，也可以是树（比如后面的多级页表）。页表的每一项是页表条目，上面有虚拟页表号，和页帧号，还可能有保护位，表示是否可读写；脏位，换入内存，是否被修改过；有效位，表明当前的页帧是在内存中，还是在硬盘上。 问题 页表很大 需要访问两次内存，一次是进入内存查询页表，获得物理帧号，再从内存中将该物理页中需要的数据或代码取出来，加载到寄存器中去。 TLBTLB放置在MMU中，维护着一部分页表条目，当进行内存访问时，先进入TLB寻找，成功，则访问物理内存中对应的页帧；不成功，再到页表中去寻找，找到，将该条目替换到TLB中，重新开始过程。 因为局部性原理，TLB能提高很多的效率。 多级页表节省了页表的产生空间,如果一级页表中的某个页表条目为空，该条目的二级页表不存在","categories":[{"name":"OS","slug":"OS","permalink":"https://zerrari.github.io/categories/OS/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}]},{"title":"Search","slug":"Search","date":"2021-03-25T10:49:37.000Z","updated":"2021-03-25T11:28:39.158Z","comments":true,"path":"2021/03/25/Search/","link":"","permalink":"https://zerrari.github.io/2021/03/25/Search/","excerpt":"","text":"SearchSequential Search顺序表查找 从第一个元素开始查找，直到找到目标为止。 Sequential Search顺序表查找 从第一个元素开始查找，直到找到目标为止。 int Sequential_Search(int *a,int n,int key) &#123; int i; for (i = 0;i &lt; n;i++) &#123; if (a[i] == key) return i; &#125; return 0; &#125; 增加哨兵来优化算法 不用每次都要和n比较大小，返回为0时，即不存在该元素。 int Sequential_Search_Better(int *a,int n,int key) &#123; int i; a[0] = key; i = n; while (a[i] != key) i--; return i; &#125; 时间复杂度：O(n) Binary Search二分查找 每次从剩下元素的中间部分开始比较，直到找到目标。 int binary_search(int *a,int n,int key) &#123; int mid,right,left; left = 1; right = n; while (left &lt;= right) &#123; mid = (left + right) / 2; if (a[mid] == key) return mid; else if (a[mid] &lt; key) left = mid + 1; else right = mid -1; &#125; return 0; &#125; 改变权值，即变成插值查找mid = low + (high - low) * (key - a[low]) / (a[high] - a[low]) 斐波那契查找 int Fibonacci_search(int* a,int n,int key) &#123; int left,right,mid,i,k; left = 0; right = n; while (n &gt; F(k) - 1) k++; for (i = n;i &lt; F(k) - 1;i++) a[i] = a[n]; while (left &lt;= right) &#123; mid = left + F(k-1) - 1; if (a[mid] &lt; key) &#123; left = mid + 1; k = k-2; &#125; else if(a[mid] &gt; key) &#123; right = mid - 1; k = k-1; &#125; else &#123; if (k &lt;= n) return mid; else return n; &#125; &#125; return 0; &#125; 时间复杂度：O(logn) Binary Sort Tree结点的左儿子小于结点的右儿子用递归来进行查找 _Bool insert_BST(BiTree *T,int key) &#123; BiTree s,p; if (!search_BST(*T, key, NULL, &amp;p) ) &#123; s = (BiTree)malloc(sizeof(BitNode)); s-&gt;data = key; s-&gt;lchild = NULL; s-&gt;rchild = NULL; if (p == NULL) *T = s; else if (key &lt; p-&gt;data) &#123; p-&gt;lchild = s; &#125; else p-&gt;rchild = s; return 1; &#125; else return 0; &#125; Hashmap Search存储位置和关键字之间确立一种对应关系。 函数构造要求 计算简单 散列地址分布均匀 处理散列冲突有时候不同的元素的散列函数值相等，形成了冲突，需要解决这种冲突。 开发定址法 一旦产生了冲突，就去寻找下一个空的地址。 如运用除数取余法 来作为散列函数时，可以将冲突的元素加d后，再散列得到地址。 如果位移量d是随机计算得到的，称之为随机探测法。 再散列函数法 事先准备多个散列函数，如果出现冲突，用下一个函数散列求地址。 链地址法 将所有关键字为同一词的元素储存在一个单链表中。 公共溢出区法 将产生冲突的元素，存放在溢出区中。 当溢出区元素较少时，查找效率较高。 性能分析 散列函数是否均匀 处理冲突的方法 散列表的装填因子（表中的记录个数和表的长度的比值） 不产生冲突的情况下，时间复杂度为O(1)。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://zerrari.github.io/categories/Algorithm/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}]},{"title":"http","slug":"http","date":"2021-03-25T05:31:56.000Z","updated":"2021-03-29T09:36:39.385Z","comments":true,"path":"2021/03/25/http/","link":"","permalink":"https://zerrari.github.io/2021/03/25/http/","excerpt":"","text":"HTTPURL统一资源定位符https://zerrari.github.io/categories/方案://服务器位置/路径 URL的第一部分是URL方案，告知客户端如何访问资源（http）。 URL的第二部分指的是服务器的位置。 URL的第三部分是资源路径。 语法scheme://user:password@host:port/path;params?query#frag scheme: 访问服务器的协议 user: 访问某些资源需要的用户名 password: 访问某些资源需要的密码 host: 服务器的主机名或IP地址 port: 服务器正在监听的端口号，默认为80 path: 资源的本地名 params: 输入参数 query: 查询参数 frag: 一部分资源的名字 URL编码%00~%8f %30/%39 0/9 %41/%5a A/Z %61/%7a a/z %25 % %20 space HTTP报文报文流不管是请求报文还是响应报文，都向下游流动。 组成部分 起始行 首部 主体 请求报文 &lt;method&gt; &lt;request-url&gt; &lt;version&gt; &lt;headers&gt; &lt;entity-body&gt; GET /specials/xxx.gif HTTP/1.1 HSOT: www.xxxxx.com 响应报文 &lt;version&gt; &lt;status&gt; &lt;reason-phrase&gt; &lt;headers&gt; &lt;entity-body&gt; HTTP/1.1 200 OK Content-Type: xxx.gif Content-Length: 12","categories":[{"name":"Network","slug":"Network","permalink":"https://zerrari.github.io/categories/Network/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}]},{"title":"Makefile","slug":"Makefile","date":"2021-03-22T08:32:00.000Z","updated":"2021-03-22T12:44:59.995Z","comments":true,"path":"2021/03/22/Makefile/","link":"","permalink":"https://zerrari.github.io/2021/03/22/Makefile/","excerpt":"","text":"Makefileintro编译文件的工具，可以有效组织大规模的源文件。 规则target... : prerequisites... command... command 前要用Tab键缩进 首先从依赖中寻找是否有比目标文件更新的文件，或者如果目标文件不存在，则运行下面的命令，并生成目标文件。 .PHONY : clean clean : -rm edit $(objects) .PHONY表示clean是一个伪目标，并不会生成这个文件，只有显式执行make clean,才会执行命令。 变量变量的声明objects = program.o foo.o utils.o变量的使用program : $(objects)","categories":[{"name":"Makefile","slug":"Makefile","permalink":"https://zerrari.github.io/categories/Makefile/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}]},{"title":"Tree","slug":"Tree","date":"2021-03-16T12:07:17.000Z","updated":"2021-03-22T08:35:03.688Z","comments":true,"path":"2021/03/16/Tree/","link":"","permalink":"https://zerrari.github.io/2021/03/16/Tree/","excerpt":"","text":"树定义树是结点的有限集。 度 结点拥有的子树的树目。 度为零的结点称为叶子结点或终端结点。度不为零的结点称为分支结点或非终端结点。 树的度是各结点度的最大值。 树中结点的最大层次称为树的深度或高度。 森林是互不相交树的集合。 树的存储结构双亲表示法 Data Parent Data 表示数据域 Parent 表示指针域，指向双亲 孩子表示法 两种结点结构 孩子链表的孩子结点|child|next||—–|—-| next 指向下一个孩子结点 child 保存某个结点在表头数组中的下标 表头数组|data|firstchild||—-|———-| data 保存数据firstchild 保存第一个孩子的头指针 孩子兄弟表示法 data firstchild rightsib rightsib 存储右兄弟指针 二叉树除了叶子结点以外，每个结点的子树的个数不超过2. 二叉树的分类 斜树 完全二叉树 满二叉树 二叉树的存储结构typedef struct BitTree &#123; ElementType data; struct BitTree *rchild ,*lchild; &#125;BitTree; 二叉树的遍历 前序遍历若二叉树为空，则空操作返回；否则先访问根结点，前序遍历左子树，再遍历右子树。 void PreOrderTraverse(BitTree T) &#123; if (&amp;T == NULL) return; printf(&quot;%c&quot;,T.data); PreOrderTraverse(T.lchild); PreOrderTraverse(T.rchild); &#125; ABDHKECFIGJ 中序遍历若二叉树为空，则空操作返回；否则从根结点开始，中序遍历左子树，然后访问根结点，再中序遍历右子树。 void InOrderTraverse(BitTree T) &#123; if (&amp;T == NULL) return; InOrderTraverse(T.lchild); printf(T.data); InOrderTraverse(T.rchild); &#125; HKDBEAIFCGJ 后序遍历若二叉树为空，则空操作返回；否则从左到右先访问左右子树，再访问根结点。 void PostOrderTraverse(BitTree T) &#123; if (&amp;T == NULL) return; PostOrderTraverse(T.lchild); PostOrderTraverse(T.rchild); printf(T.data); &#125; KHDEBIFJGCA 二叉树的建立","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"https://zerrari.github.io/categories/Data-Structure/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}]},{"title":"vim-markdown","slug":"vim-markdown","date":"2021-03-15T04:04:31.000Z","updated":"2021-03-15T04:30:04.301Z","comments":true,"path":"2021/03/15/vim-markdown/","link":"","permalink":"https://zerrari.github.io/2021/03/15/vim-markdown/","excerpt":"","text":"Markdown Vim 一种轻量级的标记语言 语法标题 # 一级标题 ## 二级标题 ### 三级标题 字体格式 *Bold* 粗体 *Italic* 斜体 ~~delete~~ 中划线 超链接 [description](url) 网页链接 ![description](url) 图片链接 表格 name address grade John China 96 Mike US 94 列表 无序列表 列表嵌套(四个空格) 有序列表 …….. Vim 快捷键 Key Function ;c insert code block ;b bold text ;i italic text ;h insert header ;p insert image ;a insert url ;s insert line ;f find &lt;++&gt; p preview markdown","categories":[{"name":"Vim","slug":"Vim","permalink":"https://zerrari.github.io/categories/Vim/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"https://zerrari.github.io/tags/Tools/"}]},{"title":"Operating System Learning-2","slug":"Operating-System-Learning-2","date":"2021-03-14T11:48:46.000Z","updated":"2021-03-22T10:59:47.739Z","comments":true,"path":"2021/03/14/Operating-System-Learning-2/","link":"","permalink":"https://zerrari.github.io/2021/03/14/Operating-System-Learning-2/","excerpt":"","text":"Operating System虚拟内存MMU 内存管理单元 利用查询表来翻译虚拟地址页表 页表是一个页表条目(PTE)的数组 程序的局部性原理时间局部性一段时间内重复执行一段代码，或者访问一组数据 空间局部性访问一段空间内的数据或者执行代码 TLB翻译后备缓冲区 由单个的PTE组成的块，来加速地址翻译 处理器产生一个虚拟地址 通过MMU产生PTE(页表条目) 通过TLB查找是否存在该页表条目 若存在，交由MMU直接翻译成物理地址 若不存在，从高速缓存中取出该条目，并放入TLB中 TLB的加入降低了访问主存的次数，原本需要访问两次主存。 多级页表优点 节省了页表的产生空间 如果一级页表中的某个页表条目为空，该条目的二级页表不存在 页表置换算法最优页面置换算法当发生缺页中断时，调入即将访问的页面。现实中无法实现。 最近未使用页面置换算法系统为每一个页面设置两个状态位 R 访问位（定期清零） M 修改位 根据两个状态位，所有的页面被分为四类： 0 没有被访问，没有被修改 1 没有被访问，被修改 2 被访问，没有被修改 3 被访问，被修改 算法随机从编号最小的页面中挑选一个淘汰 先进先出页面置换算法维护一个页面的链表。淘汰最早进入的页面，将最近的页面放在表尾。 第二次机会页面置换算法时钟页面置换算法最近最少使用页面置换算法 参考资料《深入理解计算机系统》参考资料《现代操作系统》","categories":[{"name":"OS","slug":"OS","permalink":"https://zerrari.github.io/categories/OS/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}]},{"title":"Operating System Learning","slug":"Operating-System-Learning","date":"2021-03-13T11:32:12.000Z","updated":"2021-03-22T11:13:49.191Z","comments":true,"path":"2021/03/13/Operating-System-Learning/","link":"","permalink":"https://zerrari.github.io/2021/03/13/Operating-System-Learning/","excerpt":"","text":"OS Learning计算机体系结构和内存结构 cpu cache 内存 硬盘 金字塔的结构，体积减小，速度增加 地址空间与地址生成 物理地址空间 硬件支持的地址空间 逻辑地址空间 一个运行的程序所拥有的内存范围 连续内存的分配内存碎片问题：空闲内存不能被利用 外部碎片：在分配单元间的未使用内存 内部碎片：在分配单元中的未使用内存,因为内存分配只能是二的幂次方。 内存的动态分配策略要分配空间为n的内存 首次适配 碰到的第一个比n大的空闲内存块就适配 最优适配 使用最小的可用空闲块 最坏适配 使用最大的可用空闲块 压缩式碎片整理 调整程序的储存空间，来合并空闲块 交换式碎片整理 运行程序需要更多的内存，抢占等待的程序来回收它们的内存 缺点 分配的物理地址是连续的 容易产生内存碎片问题，内存利用率低 非连续的内存分配如何建立逻辑地址和物理地址的转换 优点 分配的物理地址是非连续的 更好的内存利用 允许共享代码和数据 允许动态加载和链接分段分页 早期计算机系统，内存不够，如果程序太大，采取覆盖技术，将需要的数据和代码储存在内存中；如果程序太多，将暂时不能执行的程序放在外存中","categories":[{"name":"OS","slug":"OS","permalink":"https://zerrari.github.io/categories/OS/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}]},{"title":"Leetcode 47DW","slug":"Leetcode-47DW","date":"2021-03-07T10:54:22.000Z","updated":"2021-03-15T02:35:56.252Z","comments":true,"path":"2021/03/07/Leetcode-47DW/","link":"","permalink":"https://zerrari.github.io/2021/03/07/Leetcode-47DW/","excerpt":"","text":"Leetcode 47场双周赛Question 1找到最近的有相同X或Y坐标的点 这道题比较容易 Question 2 判断一个数字是否可以表示成三的幂的和 Method 1除三取余法三的幂次方除三取余后除了0和1不会出现其他的数 bool checkPowersOfThree(int n)&#123; int x = 0; while (n != 0) &#123; if (n % 3 == 2) return false; n = n / 3; &#125; return true; &#125; Method 2组成三的幂次方的数必然有比它小的第一个三次幂得数 bool checkPowersOfThree(int n)&#123; int max = 1; while (max &lt; 10000000) &#123; max = max * 3; &#125; while (n &gt;= 0) &#123; if (n &gt;= max) &#123; n = n - max; max = max / 3; if (max == 0) break; &#125; else max = max / 3; &#125; if (n == 0 ) return true; return false; &#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zerrari.github.io/categories/Leetcode/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}]},{"title":"Vimium","slug":"Vimium","date":"2021-02-27T09:10:05.000Z","updated":"2021-02-27T09:31:57.004Z","comments":true,"path":"2021/02/27/Vimium/","link":"","permalink":"https://zerrari.github.io/2021/02/27/Vimium/","excerpt":"","text":"VimiumIntroThe hacker’s browser.Chrome浏览器的类似vim的插件 Key f/F快速跳转链接，大写在新标签页打开，小写在当前标签页打开 x关闭当前标签页 X打开刚关闭的标签页 gg滑动到页面顶部 G滑动到页面底部 r刷新页面 i进入输入模式，自动寻找输入框 yy拷贝当前链接 o/O搜索链接，书签和历史 b/B搜索书签 /进入搜索模式，n向后匹配，N向前匹配 H/L前进和后退 J/K在不同标签中移动 T在标签页中搜索","categories":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/categories/Learning/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"https://zerrari.github.io/tags/Tools/"}]},{"title":"python爬虫实践-图片下载","slug":"python爬虫实践-图片下载","date":"2021-02-14T06:24:54.000Z","updated":"2021-02-14T07:59:50.556Z","comments":true,"path":"2021/02/14/python爬虫实践-图片下载/","link":"","permalink":"https://zerrari.github.io/2021/02/14/python%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD/","excerpt":"","text":"python crawler爬虫实践代码地址 库 Beautifulsoup Requests os RequestsRequests是一个python的http库 尝试获取某个页面r=requests.get(&lt;url&gt;)建立了一个名为r的Response对象 发送一个post请求r = requests.post(&#39;http://httpbin.org/post&#39;, data = &#123;&#39;key&#39;:&#39;value&#39;&#125;) 传递url参数 payload = &#123;&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;&#125; r = requests.get(&quot;http://httpbin.org/get&quot;, params=payload) 读取响应内容 r.text r.encoding 二进制响应内容r.content 定制请求头 url = &#39;https://api.github.com/some/endpoint&#39; headers = &#123;&#39;user-agent&#39;: &#39;my-app/0.0.1&#39;&#125; r = requests.get(url, headers=headers) 响应状态码r.status_code Beautifulsoup这是一个从HTML文件中提取数据的python库 导入from bs4 import BeautifulSoup 建立对象soup = BeautifulSoup(html_doc,&#39;lxml&#39;) Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: Tag NavigableString BeautifulSoup Comment TagTag对象与HTML中的Tag一样 获取tag的名字tag.name Tag的属性操作方法与字典一致tag[&#39;class&#39;]tag的属性可以被添加,删除或修改 遍历文档树得到所有的&lt;a&gt;标签soup.find_all(&#39;a&#39;) 得到所有的&lt;a&gt;标签，并且class=&#39;sister&#39;的标签soup.find_all(&quot;a&quot;, class_=&quot;sister&quot;) 代码目标网站 建立网页的对象并且提取图片的地址 def ana_web(url,header): response = requests.get(url,headers=header) response.encoding = &#39;gbk&#39; soup = BeautifulSoup(response.text,&#39;lxml&#39;) tags = soup.find_all(&#39;img&#39;) return tags 运用os库建立文件夹 def setDir(): print(&quot;你正处于的路径：&quot;) print(os.path.abspath(&#39;.&#39;)) now_path = os.path.abspath(&#39;.&#39;) print(&#39;\\n&#39;) dir_name = input(&#39;请输入你想保存的文件夹名称&#39;) os.mkdir(dir_name) os.chdir(now_path+&#39;/&#39;+dir_name) 下载图片并且保存到刚刚的文件夹中 def download_img(): tags=ana_web(target_url,target_header) setDir() nums = 0 for tag in tags: nums = nums + 1 img = requests.get(tag[&#39;src&#39;]).content with open(str(nums)+&#39;.jpg&#39;,&#39;wb&#39;) as f: f.write(img) f.close()","categories":[{"name":"Python","slug":"Python","permalink":"https://zerrari.github.io/categories/Python/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}]},{"title":"python学习笔记-六","slug":"python学习笔记-六","date":"2021-02-12T05:18:06.000Z","updated":"2021-02-12T05:46:26.304Z","comments":true,"path":"2021/02/12/python学习笔记-六/","link":"","permalink":"https://zerrari.github.io/2021/02/12/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AD/","excerpt":"","text":"day6 in python错误、调试和测试错误处理trytry: print(&#39;try...&#39;) r = 10 / 0 print(&#39;result:&#39;, r) except ZeroDivisionError as e: print(&#39;except:&#39;, e) else: print(&#39;no error!&#39;) finally: print(&#39;finally...&#39;) print(&#39;END&#39;) 把可能发生错误的语句放到try:里如果出现错误，则之后的语句不会被执行，跳转到except语句，最后执行finally语句 如果没有出现错误，会执行else语句，finally语句依然会被执行 错误处理语句可以跨越层级调用 调用栈如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。 记录错误import logging def foo(s): return 10 / int(s) def bar(s): return foo(s) * 2 def main(): try: bar(&#39;0&#39;) except Exception as e: logging.exception(e) main() print(&#39;END&#39;) 运用logging模块，程序打印完错误信息后，会继续执行，并正常退出。 抛出错误用raise语句抛出一个错误的实例 调试断言assert后的表达式如果是True,则断言正确，否则会抛出AssertionError 启动Python解释器时可以用-O参数来关闭assert pdbpython的调试器pdb 启动调试器python -m pdb err.py 单步执行代码n 查看变量的值p 变量名 结束调试q 在要出错的地方放置pdb.set_(trace),执行到该语句时，会进入pdb调试语句import pdbpdb.set_trace()","categories":[{"name":"Python","slug":"Python","permalink":"https://zerrari.github.io/categories/Python/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}]},{"title":"Git-三","slug":"Git-三","date":"2021-02-10T06:06:11.000Z","updated":"2021-02-10T06:34:13.241Z","comments":true,"path":"2021/02/10/Git-三/","link":"","permalink":"https://zerrari.github.io/2021/02/10/Git-%E4%B8%89/","excerpt":"","text":"Git分支HEAD为一个特殊指针，指向当前的本地分支 git branch test创建test分支 git checkout test切换到test分支 git checkout -b test创建一个名为test的新分支，并且切换到新分支上 git branch -d test删除test分支 git merge test合并test分支 git branch -v查看每个分支的最后一次提交 git branch --merged查看哪些分支已经合并到当前分支","categories":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/categories/Learning/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"https://zerrari.github.io/tags/Tools/"}]},{"title":"Git-二","slug":"Git-二","date":"2021-02-09T10:45:29.000Z","updated":"2021-02-10T06:34:54.600Z","comments":true,"path":"2021/02/09/Git-二/","link":"","permalink":"https://zerrari.github.io/2021/02/09/Git-%E4%BA%8C/","excerpt":"","text":"Git基础查看提交历史git loggit log -p会显示每次提交的差异git log --stat显示每次提交的简略信息 撤销操作git commit --amend执行此命令，最后只会有一个提交，覆盖了前面的提交 git reset &lt;file&gt;取消暂存的文件 git checkout --&lt;file&gt;取消文件的修改即恢复到上次提交的样子 远程仓库的使用git remote查看远程仓库 git remote add &lt;shortname&gt; &lt;url&gt;添加一个远程仓库，同时指定一个简单的缩写 git fetch [remote-name]拉取远程仓库中自己还没有的数据 git push [remote-name] [branch-name] git push origin master 推送到远程仓库 git remote show [remote-name]查看远程仓库的信息 git remote rename修改远程仓库的简写名 git remote rm删除远程仓库 标签git tag列出标签 创建标签标签分为： 轻量标签git tag v1.4-lw 附注标签git tag -a v1.4 -m &quot;some messages&quot; git show显示附注标签于该次提交的信息 git tag -a v1.2 9fceb02后期打标签 git push origin [tagname]将标签推送到服务器上 Git别名git config --global alias.co checkout当要输入git checkout,只要输入git co","categories":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/categories/Learning/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"https://zerrari.github.io/tags/Tools/"}]},{"title":"python学习笔记-五","slug":"python学习笔记-五","date":"2021-02-08T12:28:14.000Z","updated":"2021-02-09T05:10:13.989Z","comments":true,"path":"2021/02/08/python学习笔记-五/","link":"","permalink":"https://zerrari.github.io/2021/02/08/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%94/","excerpt":"","text":"day5 in python面向对象编程把对象作为程序的基本单元，一个对象包括了数据和操作数据的函数 类和实例类是抽象的模版，实例是根据类创造出来的具体对象 class Student(): pass mike = Student() init通过__init__方法可以在创建实例的同时，赋予对象属性 def __init_——(self,name,score): self.name = name self.score =score 参数self表示创建的实例本身 类中的函数第一个变量永远是self 访问限制如果要让内部属性不被外部访问，在属性的名称前加上两个下划线，这样变量就变成了私有变量，只能内部访问 继承和多态当我们定义一个类的时候，可以从现有的类继承，被继承的类称为父类，继承的类称为子类 dir()获得一个对象的所有属性和方法,返回一个列表 继承继承可以获得父类的全部功能 class animal(object): pass class dog(animal): pass dog类继承了animal类 多态isinstance()判断变量是否是某个类型b = animal() isinstance(b,animal) c = dog() isinstance(c,dog) c既是dog类也是animal类因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的方法，这就是多态的意思 类属性在类中定义的属性可以通过实例和累得名字来访问 class Student(object): name = student Student.name s=student() s.name","categories":[{"name":"Python","slug":"Python","permalink":"https://zerrari.github.io/categories/Python/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}]},{"title":"Git(一)","slug":"Git-一","date":"2021-02-08T05:08:45.000Z","updated":"2021-04-08T10:01:26.573Z","comments":true,"path":"2021/02/08/Git-一/","link":"","permalink":"https://zerrari.github.io/2021/02/08/Git-%E4%B8%80/","excerpt":"","text":"GitintroductionGit是分布式版本控制系统 文件的三种状态 committed staged modified config每台电脑上有三个config文件 /etc/gitconfig ~/.gitconfig 当前仓库中的config文件(.git/config)每一个级别覆盖上一个级别的配置 用户信息在命令行下输入下列命令来配置用户信息$ git config --global user.name &#39;xxx&#39;$ git config --global user.email xxx@example.com 配置默认编辑器$ git config --global core.editor vim 检查配置信息$ git config --list 通过git config &lt;key&gt;检查某一项配置 获取帮助$ git help &lt;verb&gt; $ git &lt;verb&gt; --help $ man git-&lt;verb&gt; 例如，获取config的帮助git config --help 基础获取仓库 新建一个仓库进入该项目的目录，执行git init操作，会在该目录中产生一个.git文件夹git add .追踪指定文件git commit -m &#39;the first version&#39;提交文件 克隆现有仓库克隆命令的格式为git clone [url]git clone [url] name将仓库克隆到本地并放到以name命名的文件夹中 记录更新 检查文件状态git status 跟踪新文件git add 状态简览git status -s输出更紧凑的文件状态??代表未追踪文件A代表暂存区的文件 M代表文件修改了但是没放到暂存区M 代表文件修改了放到了暂存区 忽略文件创建一个名为.gitignore以#开头的行会被忽略 查看修改git diff查看尚未暂存的文件的修改git diff -cached/git diff --staged查看暂存文件的修改 提交更新git commit -m &#39;string&#39;git commit会启动编辑器，输入提交说明 跳过使用暂存区域git commit -a 重命名文件git mv name1.file name2.file .gitignoregithub上有一个十分详细的.gitignore的仓库 移除文件git rm在已跟踪文件中删除指定文件，并从工作目录中删除 git rm --cached从git仓库中删除，但是在工作目录中保留","categories":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/categories/Learning/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://zerrari.github.io/tags/Git/"}],"author":"Zerrari"},{"title":"python学习笔记(四)","slug":"python学习笔记-四","date":"2021-02-05T13:15:58.000Z","updated":"2021-02-06T11:47:41.566Z","comments":true,"path":"2021/02/05/python学习笔记-四/","link":"","permalink":"https://zerrari.github.io/2021/02/05/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/","excerpt":"","text":"day4 in python高级特性切片通过切片可以取出list和tuple或是字符串中的部分元素索引从0开始倒数第一个元素的索引为-1 s=[&#39;john&#39;,&#39;mike&#39;,&#39;sara&#39;] s[0:2] [&#39;john&#39;,mike] s[-2:] [&#39;mike&#39;,&#39;sara&#39;] s[-1:] [&#39;sara&#39;] 固定步长切片 s=[1,2,3,4,5,6,7,8] s[::2] [1,3,5,7] 字符串 &#39;abcd&#39;[1:3] &#39;bc&#39; 迭代对dict使用迭代默认迭代dict中的key d=&#123;&#39;a&#39;:1,&#39;b&#39;:2,&#39;c&#39;:3&#125; for i in d: print(i) a b c 如果要迭代valuefor value in d.values(): 迭代字符串for char in &#39;abcd&#39;: 列表生成式list(range(1,11)) [1,2,3,4,5,6,7,8,9,10] [x*x for x in range(1,5)] [1,4,9,16] [a+c for a in&#39;ab&#39; for c in &#39;xy&#39;] [&#39;ax&#39;,&#39;ay&#39;,&#39;bx&#39;,&#39;by&#39;] if…else… [x if x % 2 == 0 else -x for x in range(1,4)] [-1,2,-3] 生成器构造一个生成器 g=(x*x for x in range(1,5)) next(g)获取下一个元素运用迭代来获得元素 for x in g: print(x) 1 4 9 16 迭代器IterableIterable可迭代对象使用isinstance()判断是否为可迭代对象isinstance(&#39;abc&#39;,Iterable) Iterator可以通过next()函数调用的迭代对象为迭代器Iterator可以通过iter()函数获得Iterator 函数式编程高级函数变量可以指向函数 f=abs f(-10) 10 函数名也可以指向变量 abs = 10 abs 10 一个函数可以作为参数传入另一个函数 def my_fun(x,y,f): print(f(x)+f(y)) my_fun(-5,10,abs) 15 map/reducemap对序列中的每个元素执行相同的操作map()接受两种参数 Iterable 函数名 list(map(abs,[1,-2,-3,4])) [1,2,3,4] reduce对序列中的元素执行累加操作 def fun(x,y): return x+y reduce(fun,[1,2,3,4]) 10 filter用来过滤序列接受一个函数，作用于每一个元素，返回值是True保留该元素 def is_odd(x) return x % 2 == 1 list(filter(is_odd,[1,2,3,4])) [1,3] sortedsorted([3,1,4,78,34]) [1,3,4,34,78] 还可以接受一个key函数来实现自定义的排序 sorted([3,-1,4,-78,34],key=abs) [-1,3,4,34,-78] 匿名函数只能有一个表达式，不能写return返回值就是该表达式的结果 list(map(lambda x:x*x,[1,2,3,4])) [1,4,9,16] 关键字lambda表示匿名函数，冒号前面的x表示函数参数","categories":[{"name":"Python","slug":"Python","permalink":"https://zerrari.github.io/categories/Python/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}]},{"title":"python学习笔记(三)","slug":"python学习笔记-三","date":"2021-02-05T10:29:53.000Z","updated":"2021-02-05T12:00:22.969Z","comments":true,"path":"2021/02/05/python学习笔记-三/","link":"","permalink":"https://zerrari.github.io/2021/02/05/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/","excerpt":"","text":"day3 in python函数函数定义def my_fun(arguments): statement return arguments 定义一个空函数 def empyt_fun(arguments): pass 函数参数默认参数def my_fun(name,age,country=&#39;China&#39;,city=&#39;Beijing&#39;): print(name) print(age) print(country) print(city) my_fun(&#39;john&#39;,20) my_fun(&#39;john&#39;,23,&#39;America&#39;) my_fun(&#39;john&#39;,22,city=&#39;Shanghai&#39;) 默认参数必须指向不变对象 可变参数允许传入任意个参数 def my_fun(*numbers): for x in numbers: print(x) my_fun(1,2,3) 关键字参数将传入参数组装成dir def person(name,**kw): print(person) print(kw) person(&#39;mike&#39;,job=&#39;teacher&#39;,city=&#39;Beijing&#39;) mike &#123;&#39;job&#39;:&#39;teacher&#39;,&#39;city&#39;:&#39;Beijing&#39;&#125; 命名关键字参数限制关键字参数的名字例如只接受job,city为参数 def person(name,*,job,city): print(name) print(job) print(city) person(&#39;john&#39;,job=&#39;teacher&#39;,city=&#39;Beijing&#39;) john teacher Beijing 参数顺序顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数 def my_fun(a,b=0,*c,*,d,**kw): pass 递归函数阶乘函数 def fact(x): if (x == 1): return 1 return fact(x-1)*x","categories":[{"name":"Python","slug":"Python","permalink":"https://zerrari.github.io/categories/Python/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}]},{"title":"python学习笔记(二)","slug":"python学习笔记(二)","date":"2021-02-04T11:52:50.000Z","updated":"2021-02-05T11:12:45.191Z","comments":true,"path":"2021/02/04/python学习笔记(二)/","link":"","permalink":"https://zerrari.github.io/2021/02/04/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/","excerpt":"","text":"Day2 in python数据类型tuple定义一个tuplename=(&#39;john&#39;,&#39;mike&#39;,&#39;lisa&#39;)定义一个空的tuplename=()定义只有一个元素的tuple用逗号来防止歧义name=(1,) 结构条件判断非空字符串，非空列表，非零数代表True if x &gt; 5: statement elif x &gt; 10 : statement else : statement 循环for … innames=[&#39;john&#39;,&#39;mike&#39;,&#39;lisa&#39;] for name in names : print(name) john mike lisa whilen=1 sum = 0 while n&lt;100 : sum = sum + n n = n + 1 print(sum) 4950 break中断当前循环 n = 1 while n &lt;= 100: if n &gt; 1: break print(n) n = n + 1 print(&#39;END&#39;) 1 END continue直接进入下一个循环，不执行下面的语句 n = 0 while n &lt; 10: n = n + 1 if n % 2 == 0: continue print(n) 1 3 5 7 9 dict and setdictdict的对应关系为”key-value” d=&#123;&#39;bob&#39;:74,&#39;mike&#39;:86,&#39;john&#39;:90&#125; d[&#39;bob&#39;] 74 key判断key是否存在 in &#39;mike&#39; in d False get()```d.get(‘mike’)Noned.get(‘mike’,-1) 1 删除key d.pop(&#39;bob&#39;) d &#123;&#39;mike&#39;:86,&#39;john&#39;:90&#125; set创建一个set重复元素自动被过滤 s=set([1,2,3]) s &#123;1,2,3&#125; s=set([1,2,2,3,4,4]) s &#123;1,2,3,4&#125; add，pop和remove方法 s.add(4) s &#123;1,2,3,4&#125; s.pop() s &#123;2,3,4&#125; s.remove(4) s &#123;2,3&#125;","categories":[{"name":"Python","slug":"Python","permalink":"https://zerrari.github.io/categories/Python/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}]},{"title":"python学习笔记","slug":"python学习笔记(一)","date":"2021-02-03T11:18:15.000Z","updated":"2021-02-03T12:49:10.271Z","comments":true,"path":"2021/02/03/python学习笔记(一)/","link":"","permalink":"https://zerrari.github.io/2021/02/03/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/","excerpt":"","text":"Day1 in python脚本式编程在命令行中运行python程序python 1.py 运行python脚本chmod +x 1.py./1.py chmod是一个用来改变文件权限的命令，*+x*为文件增加可执行权限 标识符python中的标识符可以包含英文，数字和下划线，但不能以数字开头 行和缩进python中的行的结束以新行的开始为标志可以使用斜杠\\来分隔多行语句中包含 [], {} 或 () 括号就不需要使用多行连接符 print and inputprint(&quot;hello&quot;,&quot;world&quot;)(&#39;hello&#39;,&#39;world&#39;) name=input()print(name) 格式化输出print(&quot;%d %d&quot; % (1,3))1 3 运算/结果一定为浮点数//结果为整数%结果为余数 listname=[&#39;Jordan&#39;,&#39;Mike&#39;,&#39;John&#39;] len(name) 3 方法 append pop insert索引python允许负的索引,从-1即倒数最后一个元素 tuple与list不同，tuple一旦被确定就不能改变","categories":[{"name":"Python","slug":"Python","permalink":"https://zerrari.github.io/categories/Python/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"}]},{"title":"mac下安装all-the-icons","slug":"all-the-icons","date":"2021-02-01T09:52:57.000Z","updated":"2021-03-29T09:38:07.986Z","comments":true,"path":"2021/02/01/all-the-icons/","link":"","permalink":"https://zerrari.github.io/2021/02/01/all-the-icons/","excerpt":"","text":"mac下安装all-the-iconsall-the-iconsall-the-icons是一个图标字体，用来美化Emacs的界面 InstallationInstallation in EmacsType M-x all-the-icons-install-fonts不过由于DNS污染的原因，对网站的访问被拒绝，下载不成功 解决方法：参考这个链接 Installation in terminal在Terminal中执行fc-cache -f -v不过在Mac下并没有安装成功 解决的方法是：直接将all-the-icons.el克隆到本地然后将字体移动到系统的字体文档中Mac的字体路径是/System/Library/Fonts然后又出现了新的问题Operation not permittedmac下会有rootless内核保护机制防止用户修改内核文件关闭的方法可参考这篇文章最后还要打开Terminal执行sudo mount -uw /这样就可以成功安装all-the-icons","categories":[{"name":"Emacs","slug":"Emacs","permalink":"https://zerrari.github.io/categories/Emacs/"}],"tags":[{"name":"Issues","slug":"Issues","permalink":"https://zerrari.github.io/tags/Issues/"}]},{"title":"dwm配置","slug":"dwm配置","date":"2021-01-28T11:30:21.000Z","updated":"2021-04-08T10:03:09.557Z","comments":true,"path":"2021/01/28/dwm配置/","link":"","permalink":"https://zerrari.github.io/2021/01/28/dwm%E9%85%8D%E7%BD%AE/","excerpt":"","text":"dwmintroductiondwm是一个简单易用的窗口管理器 configdwm由C语言编写而成修改配置文件是通过修改头文件(即.h文件)来完成的dwm已提供了默认的配置文件config.def.hconfig.h是用户的配置文件运行dwm的过程和编译.c文件的过程一样sudo makesudo make clean install这是我的配置文件config windows key这是一个修饰键，通过和其他按键的组合可以操作窗口的布局默认的修饰键是Mod1(Alt)如果想修改修饰键找到config.h中的x#define MODKEY Mod1Mask修改Mod1Mask即可，Windows键为Mod4Mask layoutsdwm分为三种窗口布局可以通过不同的按键来切换不同的窗口布局 tiled []= [Win] + t floating &gt;&lt;&gt; [Win] + f monocle [m] [Win] + m windows model一个windows分为master和stack区域，打开一个程序，会将原本存在的程序放到stack区域中[Win]+[Enter]切换master和stack中的程序 keybindings command function [Win]+[Enter] launch terminal [Win]+s launch dwm [Win]+j/[Win]+k move to another client [Win]+[Shift]+2 move terminal to tag 2 [Win]+[Shift]+q quit dwm [Win]+[h]/[Win]+l set the width of stack area [win]+[c]/[Win]+v set the layouts [Win]+q quit the client status bar状态栏是一个可以显示系统一些信息的地方dwm提供了两种配置状态栏的方法 通过脚本文件即script 通过编写的程序，如slstatus让状态栏显示信息的命令十分简单xsetroot -name $status slstatus我使用了slstatus来配置我的状态栏这是我的配置文件config patches可以通过打补丁的方法来增加dwm的不同特性补丁是一个.diff文件打补丁的命令patch &lt; 补丁文件名 本人使用的补丁： dwm-colorbar-6.2.diff","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zerrari.github.io/categories/Linux/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"https://zerrari.github.io/tags/Tools/"}],"author":"Zerrari"},{"title":"My Archlinux","slug":"My-Archlinux","date":"2021-01-28T07:13:50.000Z","updated":"2021-02-05T12:02:19.376Z","comments":true,"path":"2021/01/28/My-Archlinux/","link":"","permalink":"https://zerrari.github.io/2021/01/28/My-Archlinux/","excerpt":"","text":"My Archlinuxinstallation参照Archlinux官网的安装教程 issues in installation安装重启前一定要安装好网络连接工具这里我安装的是networkmanager,附带有图形界面的网络管理器nmtui 解除rfkill的无线网卡禁用rfkill list如果soft blocked是no的状态rfkill unblock wifi tools用pacman命令安装工具sudo pacman -S dwm emacs st dmen networkmanager dwm一个简洁的窗口管理器 emacs一个强大的代码编辑器s st一个快速的终端模拟器 dmenu一个快速的程序启动器 networkmanager网络管理器 fish一个开箱即用的shell","categories":[{"name":"Archlinux","slug":"Archlinux","permalink":"https://zerrari.github.io/categories/Archlinux/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"https://zerrari.github.io/tags/Tools/"}]},{"title":"Emacs+Hexo","slug":"Emacs-Hexo","date":"2021-01-28T05:20:58.000Z","updated":"2021-04-08T09:55:25.906Z","comments":true,"path":"2021/01/28/Emacs-Hexo/","link":"","permalink":"https://zerrari.github.io/2021/01/28/Emacs-Hexo/","excerpt":"","text":"Emacs + Hexo 打造高效博客写作方案Hexo什么是HexoHexo是一个快速、简洁且高效的博客框架。 安装指南 官网的文档十分的详细，并且有简体中文版本。参考官网即可。 Emacs什么是EmacsEmacs是一个功能强大的编辑器。本文通过一个Emacs插件来完成在Emacs上利用Hexo书写博客。 安装指南hexo.el 效果最后，通过，一系列快捷键就可以在Emacs中完成Hexo博客的相关操作 command function M-p b start hexo M-p RET open file M-p SPC show article info M-p D delete file M-p N new file M-p M a add tags M-p M r remove tags M-p m mark M-p u unmark M-p s r run server M-p s s stop server M-p s d deploy","categories":[{"name":"Emacs","slug":"Emacs","permalink":"https://zerrari.github.io/categories/Emacs/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"https://zerrari.github.io/tags/Tools/"}],"author":"Zerrari"}],"categories":[{"name":"cpp","slug":"cpp","permalink":"https://zerrari.github.io/categories/cpp/"},{"name":"OS","slug":"OS","permalink":"https://zerrari.github.io/categories/OS/"},{"name":"Compress","slug":"Compress","permalink":"https://zerrari.github.io/categories/Compress/"},{"name":"Vim","slug":"Vim","permalink":"https://zerrari.github.io/categories/Vim/"},{"name":"Linux","slug":"Linux","permalink":"https://zerrari.github.io/categories/Linux/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://zerrari.github.io/categories/Algorithm/"},{"name":"Network","slug":"Network","permalink":"https://zerrari.github.io/categories/Network/"},{"name":"Makefile","slug":"Makefile","permalink":"https://zerrari.github.io/categories/Makefile/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://zerrari.github.io/categories/Data-Structure/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://zerrari.github.io/categories/Leetcode/"},{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/categories/Learning/"},{"name":"Python","slug":"Python","permalink":"https://zerrari.github.io/categories/Python/"},{"name":"Emacs","slug":"Emacs","permalink":"https://zerrari.github.io/categories/Emacs/"},{"name":"Archlinux","slug":"Archlinux","permalink":"https://zerrari.github.io/categories/Archlinux/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://zerrari.github.io/tags/Learning/"},{"name":"OS","slug":"OS","permalink":"https://zerrari.github.io/tags/OS/"},{"name":"Linux","slug":"Linux","permalink":"https://zerrari.github.io/tags/Linux/"},{"name":"Tools","slug":"Tools","permalink":"https://zerrari.github.io/tags/Tools/"},{"name":"Git","slug":"Git","permalink":"https://zerrari.github.io/tags/Git/"},{"name":"Issues","slug":"Issues","permalink":"https://zerrari.github.io/tags/Issues/"}]}